#include "nw.h"
#include "common.h"
#include "wiring.h"
#include "config.h"
#include "ui.h"

// This header is auto-generated by the pre-build script
// It has definitions for HTML and CSS page contents corresponding to minified versions of the pages in /pages
#include "page_content.h"
// Use ESP8266 SDK directly for enterprise wifi
#include "user_interface.h"
#include "wpa2_enterprise.h"
#include "coredecls.h"
#include "c_types.h"

#include <Arduino.h>
#include <ESP8266WiFi.h>
#include <ESP8266mDNS.h>
#include <stdio.h>
#include <string.h>


void quoted(char *buf, const char *str, char quote = '\"') {
    buf[0] = quote;
    strcpy(buf + 1, str);
    int len = strlen(str);
    buf[len] = quote;
    buf[len + 1] = '\0';
}


namespace nw {

    const char *hostname = "sup";

    const IPAddress ip_local(192, 168, 0, 1);
    const IPAddress ip_gateway(192, 168, 0, 1);
    const IPAddress ip_subnet(255, 255, 255, 0);

    int connect_status = WL_DISCONNECTED;
    String input_ssid, input_password;
    unsigned long restart_at = 0;

    void enterprise_connect(const char *ssid, const char *username, const char *identity, const char *password) {
        disable_extra4k_at_link_time();
        enable_wifi_enterprise_patch();
        wifi_set_opmode(STATION_MODE);

        station_config conf;
        memset(&conf, 0, sizeof(station_config));
        strncpy(reinterpret_cast<char *>(conf.ssid), ssid, 32);
        strncpy(reinterpret_cast<char *>(conf.password), password, 64);
        wifi_station_set_config_current(&conf);

        wifi_station_set_wpa2_enterprise_auth(true);
        wifi_station_clear_cert_key();
        wifi_station_clear_enterprise_ca_cert();
        wifi_station_clear_enterprise_identity();
        wifi_station_clear_enterprise_username();
        wifi_station_clear_enterprise_password();
        wifi_station_clear_enterprise_new_password();

        wifi_station_set_enterprise_identity(const_cast<u8*>(reinterpret_cast<const u8*>(identity)), strlen(identity));
        wifi_station_set_enterprise_username(const_cast<u8*>(reinterpret_cast<const u8*>(username)), strlen(username));
        wifi_station_set_enterprise_password(const_cast<u8*>(reinterpret_cast<const u8*>(password)), strlen(password));

        wifi_station_connect();
    }

    void decode_wifi_status(int status, char *buf) {
        const char *status_str;
        switch (status) {
        case WL_NO_SSID_AVAIL:
            status_str = PSTR("Connect Failed (Invalid SSID)");
            break;
        case WL_CONNECTED:
            status_str = PSTR("Connected");
            break;
        case WL_CONNECT_FAILED:
            status_str = PSTR("Connect Failed");
            break;
        case WL_WRONG_PASSWORD:
            status_str = PSTR("Connect Failed (Wrong Password)");
            break;
        case WL_DISCONNECTED:
            status_str = PSTR("Not Connected");
            break;
        case -2:
            status_str = PSTR("Not Connected (Manually Skipped)");
            break;
        default:
            status_str = PSTR("Unknown");
            break;
        }
        strcpy_P(buf, status_str);
    }

    void set_country() {
        wifi_country_t c = {
            .schan = 1,
            .nchan = config::global_config.wifi_nchan,
            .policy = WIFI_COUNTRY_POLICY_MANUAL,
        };
        c.cc[0] = config::global_config.wifi_ccode[0];
        c.cc[1] = config::global_config.wifi_ccode[1];
        c.cc[2] = '\0';
        wifi_set_country(&c);
    }

    void wifi_connect(bool use_saved) {
        DEBUG_OUT_FP(PSTR("MAC address: %s\n"), WiFi.macAddress().c_str());
        // Try to connect with saved network
        WiFi.persistent(false);
        WiFi.mode(WIFI_STA);
        WiFi.hostname(hostname);

        connect_status = -2;
        if (use_saved) {
            
            if (config::global_config.ent_enabled) {
                DEBUG_OUT_LN(F("Connecting to saved WPA2-Enterprise"));
                enterprise_connect(config::global_config.ent_ssid, config::global_config.ent_username,
                    config::global_config.ent_username, config::global_config.ent_password);
            }
            else {
                DEBUG_OUT_LN(F("Connecting to saved WPA2-PSK"));
                WiFi.begin();
            }
            set_country();

            ui::set_icon(ui::IconType::SPINNER);
            ui::set_text("WiFi", "Connecting");
            ui::status_led.blink(400);
            connect_status = WiFi.waitForConnectResult();
        }

        if (connect_status == WL_CONNECTED) {
            DEBUG_OUT_LN(F("Connected to saved network"));
            ui::status_led.set(false);
            return;
        }

        if (connect_status > 0) {
            ui::error_led.blink(200, connect_status);
        }
        char status_str[64];
        decode_wifi_status(connect_status, status_str);
        DEBUG_OUT_FP(PSTR("Can't connect to saved network: %s\n"), status_str);


        // In case of failure, run the access point + config server
        while (connect_status != WL_CONNECTED) {
            ui::set_icon(ui::IconType::ERROR);
            ui::set_text(connect_status == -2 ? "Config Mode" : "WiFi Error", "Use web config");
            ui::status_led.set(true);

            // Enable access point
            init_ap();
            if (!MDNS.begin(hostname)) {
                DEBUG_OUT_LN(F("Can't start mDNS"));
            }
            {
                // Run the server until we have the SSID and password
                ESP8266WebServer server(80);
                init_server(server);
                server.begin();
                DEBUG_OUT_LN(F("Server is online"));
                while (connect_status != -1) {
                    MDNS.update();
                    server.handleClient();
                    if (restart_at && millis() > restart_at) {
                        ESP.restart();
                    }
                }
            }
            // This delay seems to be necessary, otherwise the last page will time out
            delay(2000);
            WiFi.softAPdisconnect(true);

            // Try connecting here
            if (!config::global_config.ent_enabled) {
                DEBUG_OUT_FP(PSTR("(WPA2-PSK) Connecting to SSID: %s, password: %s\n"), 
                    input_ssid.c_str(), input_password.c_str());
                // Temporarily turn on persistent mode so the new SSID/password gets saved
                WiFi.persistent(true);
                WiFi.begin(input_ssid, input_password);
                WiFi.persistent(false);
                set_country();
            }
            else {
                DEBUG_OUT_FP(PSTR("(WPA2-Enterprise) Connecting to SSID: %s, username: %s, password: %s\n"),
                    config::global_config.ent_ssid, config::global_config.ent_username, config::global_config.ent_password);
                // Band-aid fix
                // Not enough memory to connect and then use firebase after this point (#1)
                DEBUG_OUT_LN(F("Software reset to reconnect"));
                ESP.restart();
                // enterprise_connect(config::global_config.ent_ssid, config::global_config.ent_username,
                //     config::global_config.ent_username, config::global_config.ent_password);
            }
            // Wait for connection while flashing
            ui::set_icon(ui::IconType::SPINNER);
            ui::set_text("WiFi", "Connecting");
            ui::status_led.blink(400);
            if ((connect_status = WiFi.waitForConnectResult()) != WL_CONNECTED) {
                DEBUG_OUT_LN(F("Failed to connect!"));
                if (connect_status > 0) {
                    ui::error_led.blink(200, connect_status);
                }
            }
        }
        ui::status_led.set(false);
    }

    void init_ap() {
        WiFi.mode(WIFI_AP);
        WiFi.softAPConfig(ip_local, ip_gateway, ip_subnet);
        WiFi.softAP(config::global_config.ap_ssid, config::global_config.ap_password);
    }

    void init_server(ESP8266WebServer &server) {
        server.on("/", HTTP_GET, [&server]() {
            server.sendHeader("Location", "/config");
            server.send(301, "text/plain", "");
        });
        server.on("/stylesheet.css", HTTP_GET, [&server]() {
            server.send_P(200, PSTR("text/css"), PSTR(PAGE_CONTENT_STYLESHEET_CSS));
        });
        // For debug
        server.on("/status", HTTP_GET, [&server]() {
            char buf[20];
            snprintf_P(buf, sizeof(buf), "Status: %d", connect_status);
            server.send(200, "text/plain", buf);
        });
        // Main configuration UI
        server.on("/config", HTTP_GET, [&server]() {
            server.send_P(200, PSTR("text/html"), PSTR(PAGE_CONTENT_CONFIG_HTML));
        });
        server.on("/config-db", HTTP_GET, [&server]() {
            constexpr size_t buf_size = 1024;
            static_assert(sizeof(PAGE_CONTENT_CONFIG_DB_HTML) + 256 < buf_size, "Buffer too small");
            char *buf = new char[buf_size];
            snprintf_P(buf, buf_size, PSTR(PAGE_CONTENT_CONFIG_DB_HTML),
                config::global_config.db_auth_password,
                config::global_config.db_auth_email,
                config::global_config.db_auth_password,
                config::global_config.db_data_location
            );

            server.send(200, "text/html", buf);
            delete[] buf;
        });
        server.on("/config-wifi", HTTP_GET, [&server]() {
            char status_str[64];
            decode_wifi_status(connect_status, status_str);
            // Get the saved network SSID and password
            station_config conf;
            memset(&conf, 0, sizeof(conf));
            wifi_station_get_config_default(&conf);
            char ccode[3] = {0};
            ccode[0] = config::global_config.wifi_ccode[0];
            ccode[1] = config::global_config.wifi_ccode[1];

            constexpr size_t buf_size = 3072;
            static_assert(sizeof(PAGE_CONTENT_CONFIG_WIFI_HTML) + 512 < buf_size, "Buffer too small");
            char *buf = new char[buf_size];
            snprintf_P(buf, buf_size, PSTR(PAGE_CONTENT_CONFIG_WIFI_HTML),
                status_str,
                config::global_config.ent_enabled ? "WPA2-Enterprise" : "WPA2-PSK",
                WiFi.macAddress().c_str(),
                conf.password,
                conf.ssid,
                conf.password,
                config::global_config.ent_password,
                config::global_config.ent_ssid,
                config::global_config.ent_username,
                config::global_config.ent_password,
                ccode,
                config::global_config.wifi_nchan);

            server.send(200, "text/html", buf);
            delete[] buf;
        });
        server.on("/config-ap", HTTP_GET, [&server]() {
            constexpr size_t buf_size = 1024;
            static_assert(sizeof(PAGE_CONTENT_CONFIG_AP_HTML) + 256 < buf_size, "Buffer too small");
            char *buf = new char[buf_size];
            snprintf_P(buf, buf_size, PSTR(PAGE_CONTENT_CONFIG_AP_HTML),
                config::global_config.ap_password,
                config::global_config.ap_ssid,
                config::global_config.ap_password
            );

            server.send(200, "text/html", buf);
            delete[] buf;
        });
        server.on("/config-update", HTTP_GET, [&server]() {
            server.send_P(200, PSTR("text/html"), PSTR(PAGE_CONTENT_CONFIG_UPDATE_HTML));
        });
        // Config backend
        server.on("/wifi-connect", HTTP_POST, [&server]() {
            if (!server.hasArg("ssid")) {
                server.send(400, "text/plain", "Bad Request");
                return;
            }
            input_ssid = server.arg("ssid");
            input_password = server.hasArg("password") ? server.arg("password") : "";
            // Disable enterprise wifi if it's not already disabled
            if (config::global_config.ent_enabled) {
                config::global_config.ent_enabled = false;
                config::save_config();
            }
            server.send_P(200, PSTR("text/html"), PSTR(PAGE_CONTENT_WIFI_SUCCESS_HTML));
            // Set this to indicate that we should reconnect now
            connect_status = -1;
        });
        server.on("/wifi-connect-enterprise", HTTP_POST, [&server]() {
            if (!(server.hasArg("ssid") && server.hasArg("username") && server.hasArg("password"))) {
                server.send_P(400, PSTR("text/plain"), PSTR("Bad Request"));
                return;
            }
            strncpy(config::global_config.ent_ssid, server.arg("ssid").c_str(), 32);
            strncpy(config::global_config.ent_username, server.arg("username").c_str(), 32);
            strncpy(config::global_config.ent_password, server.arg("password").c_str(), 64);
            config::global_config.ent_enabled = true;
            config::save_config();
            server.send_P(200, PSTR("text/html"), PSTR(PAGE_CONTENT_WIFI_SUCCESS_HTML));
            connect_status = -1;
        });
        server.on("/wifi-country-config", HTTP_POST, [&server]() {
            if (!(server.hasArg("code") && server.hasArg("nchan"))) {
                server.send_P(400, PSTR("text/plain"), PSTR("Bad Request"));
                return;
            }
            const char *ccode = server.arg("code").c_str();
            config::global_config.wifi_ccode[0] = ccode[0];
            config::global_config.wifi_ccode[1] = ccode[1];
            config::global_config.wifi_nchan = atoi(server.arg("nchan").c_str());
            config::save_config();
            server.send_P(200, PSTR("text/html"), PSTR(PAGE_CONTENT_SUCCESS_HTML));
        });
        server.on("/db-credentials", HTTP_POST, [&server]() {
            if (!(server.hasArg("email") && server.hasArg("password") && server.hasArg("location"))) {
                server.send_P(400, PSTR("text/plain"), PSTR("Bad Request"));
                return;
            }
            strncpy(config::global_config.db_auth_email, server.arg("email").c_str(), 64);
            strncpy(config::global_config.db_auth_password, server.arg("password").c_str(), 32);
            strncpy(config::global_config.db_data_location, server.arg("location").c_str(), 32);
            config::save_config();
            server.send_P(200, "text/html", PSTR(PAGE_CONTENT_SUCCESS_HTML));
        });
        server.on("/ap-setup", HTTP_POST, [&server]() {
            if (!(server.hasArg("ssid") && server.hasArg("password"))) {
                server.send_P(400, PSTR("text/plain"), PSTR("Bad Request"));
                return;
            }
            strncpy(config::global_config.ap_ssid, server.arg("ssid").c_str(), 32);
            strncpy(config::global_config.ap_password, server.arg("password").c_str(), 32);
            config::save_config();
            server.send_P(200, PSTR("text/html"), PSTR(PAGE_CONTENT_SUCCESS_HTML));
        });
        // https://github.com/esp8266/Arduino/blob/master/libraries/ESP8266WebServer/examples/WebUpdate/WebUpdate.ino
        server.on("/update", HTTP_POST, [&server]() {
            server.sendHeader("Connection", "close");
            if (Update.hasError()) {
                const char *err;
                switch (Update.getError()) {
                case UPDATE_ERROR_WRITE:
                    err = PSTR("Update failed: Flash Write Failed");
                case UPDATE_ERROR_ERASE:
                    err = PSTR("Update failed: Flash Erase Failed");
                case UPDATE_ERROR_READ:
                    err = PSTR("Update failed: Flash Read Failed");
                case UPDATE_ERROR_SPACE:
                    err = PSTR("Update failed: Not Enough Space");
                case UPDATE_ERROR_SIZE:
                    err = PSTR("Update failed: Bad Size Given");
                case UPDATE_ERROR_STREAM:
                    err = PSTR("Update failed: Stream Read Timeout");
                case UPDATE_ERROR_NO_DATA:
                    err = PSTR("Update failed: No data supplied");
                case UPDATE_ERROR_MD5:
                    err = PSTR("Update failed: MD5 hash of firmware does not match");
                case UPDATE_ERROR_SIGN:
                    err = PSTR("Update failed: Signature verification failed");
                case UPDATE_ERROR_FLASH_CONFIG:
                    err = PSTR("Update failed: Flash config wrong");
                case UPDATE_ERROR_NEW_FLASH_CONFIG:
                    err = PSTR("Update failed: New flash config wrong");
                case UPDATE_ERROR_MAGIC_BYTE:
                    err = PSTR("Update failed: Magic byte is wrong, not 0xE9");
                case UPDATE_ERROR_BOOTSTRAP:
                    err = PSTR("Update failed: Invalid bootstrapping state, reset ESP8266 before updating");
                default:
                    err = PSTR("Update failed: Unknown error");
                }
                server.send_P(200, PSTR("text/plain"), err);
            }
            else {
                server.send_P(200, PSTR("text/html"), PAGE_CONTENT_UPDATE_SUCCESS_HTML);
                restart_at = millis() + 1000;
            }
        }, [&server]() {
            HTTPUpload &upload = server.upload();
            // Start OTA update
            if (upload.status == UPLOAD_FILE_START) {
                // Stop mDNS since UDP takes priority over TCP
                WiFiUDP::stopAll();
                DEBUG_OUT_FP(PSTR("Webserver OTA update: %s\n"), upload.filename.c_str());
                if (!Update.begin((ESP.getFreeSketchSpace() - 0x1000) & 0xFFFFF000)) {
                    Update.printError(Serial);
                }
            }
            else if (upload.status == UPLOAD_FILE_WRITE && Update.isRunning()) {
                if (Update.write(upload.buf, upload.currentSize) == upload.currentSize) {
                    DEBUG_OUT_FP(PSTR("Wrote %u bytes (total %u bytes)\n"), upload.currentSize, upload.totalSize);
                }
                else {
                    Update.printError(Serial);
                }
            }
            else if (upload.status == UPLOAD_FILE_END && Update.isRunning()) {
                if (Update.end(true)) {
                    DEBUG_OUT_FP(PSTR("Update success (total size %u)\n"), upload.totalSize);
                }
                else {
                    Update.printError(Serial);
                }
            }
            else if (upload.status == UPLOAD_FILE_ABORTED) {
                DEBUG_OUT_LN(F("Update aborted!"));
            }
            yield();
        });
    }
}
